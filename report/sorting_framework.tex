\label{sort-fram}
Let's start describing this layer by showing what kind of informations a user needs to provide the system for launching a computation. We can think that in our system, a computation (that is sorting a data set) can be identified by a \textit{5-tuple}:
\begin{center}
$\langle n$, $M$, $s$, $\Lambda$, $\sigma \rangle$
\end{center} 
where $n$ is the parallelism degree of the computation, $M$ the size of the data set, $s \in N$ a seed to initialize a a pseudo-random number generator, $\Lambda$ idetifies a specific sorting algorithm, $\sigma$ a set of additional (and optional) parameters depending on $\Lambda$.
The Sorting Framework layer takes these parameters to implement a set of fundamental services, namely: 

\paragraph{Initialization of the computation ($n$, $M$, $\Lambda$, $\sigma$)} A computation is formed by a set of $n$ MPI-processes. Each process has to execute $\Lambda(\sigma)$ on a fraction of the $M$ elements. Once the computation is launched, none of the $n$ processes, except the one of rank $0$, know the value of $\langle M$, $\Lambda$, $\sigma \rangle$; this is a limitation inherited by MPI itself. Sorting Framework addresses this issue by broadcasting all the processes a data structure, named TestInfo, which contains all the characteristics of the computation that is going to be performed. Once known $\Lambda$, each process dynamically loads the code of the proper sorting function (mergesort, quicksort, ...) and starts doing its job.  
\paragraph{data set generation ($s$, $M$)} Users may request the Sorting Framework to generate a data set of size $M$. The data set is pseudo-random, that is it is created by initializing a pseudo-random numbers generator with a user-defined seed $s$. Therefore, a data set can be uniquely identified by $\langle s$, $M \rangle$. If the Sorting Framework already owns the data set identified by $\langle s$, $M \rangle$, then the data set generation may be skipped (TODO:is it true?). This is very important because the data set generation may take a lot of time, even minutes or hours, depending on the value of $M$ and the ''speed'' of the machine on which is run Rank $0$, which is requested to perform this sequential computation. To generation of data sets of 32-bits integers rely on the so called \textit{KISS generator} (Keep It Simple Stupid) which is a fast and powerful random number generator.

\paragraph{Data set loading loading and storing ($n$, $M$)} As we have anticipated in~\ref{assumptions}, the data set is loaded by a single process and then it is scattered to all other ones. Rank $0$ addresses this duty. As soon as TestInfo has been broadcasted, Rank $0$ loads the data set and sends $\frac{M}{n}$ elements to each other process. Rank $0$ even gathers the sorted data set and write it on secondary memory.

\paragraph{Timing functions} Sorting Framework provides users with the datatype $PhaseHandle$. A $PhaseHandle$ represents a phase of the algorithm. A phase is a logic, user-defined, sequence of instructions identified within the algorithm,  e.g. scattering and gathering of datas, sequential computation, splitting of pivots and so on. Different phases of the same algorithm can be identified by as many $PhaseHandle$. Beyond structuring the algorithm from a logical point of view, we use $PhaseHandle$ to obtain the time spent by the process for performing that phase. By enclosing a sequence of instructions within two functions $startPhase(PhaseHandle*)$ and $stopPhase(PhaseHandle*)$ we can respectively initialize and terminate a phase. Once a phase is stopped, the PhaseHandle will contain the time elapsed in computing that phase. 

\paragraph{Debugging functions} When the Sorting Framework is compiled, two executables are provided to the users. One of them is the ''debugging'' version, called $spddbg$. We may exploit $spddbg$ to find bugs and malfunctions of the Sorting Framework, but even for checking ''on-fly'' whether the sorted data set has been ''really sorted'' or not, that is to check that the Sorting Algorithm behaves properly. If a computation launched with $spddbg$ ends without returning any notification messages, then everything gone right. We spent lot of efforts in implementing a proper debugging system; we hope this may be helpful for future extensions to the project. 

\paragraph{Sequential Sort} The Sorting Framework provides processes with an algorithm to perform a \textit{sequential sort} of the elements locally stored. The sequential sort is based on the well-known \textit{multi-way mergesort}~\cite{FERR} which is very powerful to sort data sets that have to be stored on disk. The standard ANSI $qsort$ is used as building block for the multi-way mergesort for sorting blocks of elements which instead fits the primary memory. \\

Notice that to implement some of these functionalities, Sorting Framework relies on the DAL: for instance, the loading of the data set needs to exploit the DAL in order to let Sorting Algorithms abstract from where the data set has been loaded (main memory or has been kept on disk).

