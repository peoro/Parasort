\label{terminology}
\subsection*{Terminology}
We briefly describe the terminology that we are going to use in this chapter. Our parallel algorithms have been implemented on top of MPI, thus they are composed by a set of $N$ processes, each of them having its unique identifier. According to the MPI terminology, we refer to a specific process by calling it $rank$ $x$, where $x \in N$ represents its identifier. The input sequence $S$ that has to be ordered is of size $n$. We call \textit{step} a time interval in which a process either is \textit{active}, that is it performs sequential computation, or \textit{sleeps}. Two steps are separated by a phase of communication. A Sorting Algorithm is composed of some steps. During each step, a process contributes to the sorting of the whole data set by making a sequential computation which depends on the logic of the algorithm. It is possible that after a certain step, a process will be no more useful for the computation: in this case, that process is said to sleep. Once a step is terminated, processes are involved in a phase of communication (''stencil''). We will call \textit{sender} a process that sends data to a process \textit{receiver}.

In order to define the \textit{Algorithm Efficiency} $\varphi$ of an algorithm, we have to introduce some parameters:
\begin{itemize}
\item $m$, the number of steps of the algorithm;
\item $T_i$, the duration of step $i$ (in seconds);
\item $X_i$, a random variable which counts the number of active processes that contribute to the calculation during the step $i$.
\end{itemize}
Therefore, we can define the efficiency as:
\begin{center}
$\varphi = \frac{\sum_{i=0}^m \frac{E[X_i]}{N}}{m} = \frac{\sum_{i=0}^m E[X_i]}{N \times m} $
\end{center}
The Algorithm Efficiency is a formal tool to establish how much an algorithm exploits the parallelism degree of a machine. $\varphi \rightarrow 1$ means that the algorithm, in each step, tends to use all the available processor of the machine. Obviously, $\varphi \rightarrow 1$ does not means that the algorithm is ''good''; indeed, for such claim, the value of both $m$ and $T_i$ must be considered. For instance, we might have $\varphi \rightarrow 1$ and $T_i \rightarrow\infty$, meaning that each step requires a lot of time; or even worse, $m \rightarrow\infty$, meaning that the algorithm requires a lot of steps in which almost all the processors are involved. Again, we may have $\varphi \rightarrow \frac{1}{2}$, but with the computation that in reality is concentrated in a single step $i$, where $X_i \approx N$ and $T_i \rightarrow Time\ Completion\ of\ the\ computation$. So, we remark, the Algorithm Efficiency is interesting when for every $i, j:$ $T_i \approx T_j$, because it aims at understanding how many processes are exploited actually by the Sorting Algorithm.


